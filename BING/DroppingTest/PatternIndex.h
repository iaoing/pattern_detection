#ifndef __PATTERNINDEX_H__
#define __PATTERNINDEX_H__

//#include "IOStore.h"
#include <iostream>
#include <vector>
#include <string>
#include <string.h>
#include <map>
#include <assert.h>
#include <unistd.h>
#include <stdio.h>
#include <sstream>
//#include "ByteRangeIndex.h"
//#include "Index.h"

using namespace std;

#define PATTERN_LOGICAL_FLAG 1
#define PATTERN_PHYSICAL_FLAG 2
#define PATTERN_LENGTH_FLAG 3
#define SearchWindow 4


//////////////////
//some tools
//////////////////

off_t string_to_off(string str);


//////////////////
//some classes
//////////////////

class HostEntry
{
 public:
    /* constructors */
    HostEntry(){
    };
    HostEntry(off_t o, off_t p, size_t s, pid_t id){
    	this->logical_offset = o;
    	this->physical_offset = p;
    	this->length = s;
    	this->id = id;
    }
    
    void setBegin(double t)
    {
    	this->begin_timestamp = t;
    }
    
    void setEnd(double t)
    {
    	this->end_timestamp = t;
    }
    
    void show(){
    	cout << "logical: " << this->logical_offset << "\t"
    	     << "physical: " << this->physical_offset << "\t"
    	     << "length: " << this->length << "\t"
    	     << "pid: " << this->id << "\t"
    	     << "beginTime: " << this->begin_timestamp << "\t"
    	     << "endTime: " << this->end_timestamp << "\t"
    	     << endl;
    }
    
    off_t get_logical_offset(){return this->logical_offset;}
    off_t get_physical_offset(){return this->physical_offset;}
    size_t get_length(){return this->length;}
    double get_begin_timestamp(){return this->begin_timestamp;}
    double get_end_timestamp(){return this->end_timestamp;}
    pid_t get_id(){return this->id;}
    
 protected:
    off_t  logical_offset;    /* logical offset in container file */
    off_t  physical_offset;   /* physical offset in data dropping file */
    size_t length;            /* number of data bytes, can be zero */
    double begin_timestamp;   /* time write started */
    double end_timestamp;     /* time write completed */
    pid_t  id;                /* id (to locate data dropping) */

};

class PatternIndexCollect
{
	public:
		PatternIndexCollect(){
		};
		//~PatternIndexCollect();
		void push_entry(HostEntry h_entry);

		void show();	//for debug;

	//private:
		std::vector<off_t> collect_logical;
		std::vector<off_t> collect_physical;
		std::vector<size_t> collect_length;
		std::vector<double> collect_begin;
		std::vector<double> collect_end;
};

class PatternElem 
{
	public:
		PatternElem(){
		};
		~PatternElem(){
			// init.clear();
			// init.resize(0);
			seq.clear();
			seq.resize(0);
		};		

		int size();						//return size of seq;
		bool is_repeating();			//if all elem in seq is same that means is repeating;
		void pop(int n);				//delete the last n elems from seq;
		
		//for write; Serialization;
		size_t append_to_buf(string *buf);

		//for read; DeSerialization;
		//void get_ibuf_elem(void *ibuf);

		void show();					//for debug;

	// private:
		long int init;
		int cnt;					//using string to store off_t or size_t BUT not using template;
		std::vector<off_t> seq;
};

class PatternUnit
{
	public:
		PatternUnit(){
		};
		//~PatternUnit();

		//for write; Serialization;
		size_t append_to_buf(string *buf);

		//for read; DeSerialization;
		void get_ibuf_unit(string ibuf);

		void show();								//for debug;
		
	// private:
		PatternElem pat_off;						//one logical correponding multiple physical or length;
		std::vector<PatternElem> pat_phy;
		std::vector<PatternElem> pat_len;
};

//PatternEntry is to store the off generated by the same process(have the same pid);
class PatternEntry
{
	public:
		PatternEntry(){};
		//~PatternEntry(){};
		
		//for write; Serialization;
		size_t append_to_buf(string *buf);

		//for read; DeSerialization;
		void get_ibuf_entry(string ibuf);

		void show();				//for debug;

	// private:
		pid_t id;
		std::vector<PatternUnit> entry;
		std::vector<double> collect_begin;
		std::vector<double> collect_end;
};

class PatternIndex
{
	public:
		PatternIndex(){
		};
		~PatternIndex(){
			index_collect.clear();
			p_writebuf.clear();
			p_writebuf.resize(0);
		};

		void collectIndex(HostEntry h_entry);
		void pattern_detection(); //The main function of pattern detection.
		PatternEntry pattern_by_pid(pid_t id);
		std::vector<PatternElem> build_off_pat(int type, int begin, int end, pid_t id);
		std::vector<off_t> build_delta(int type, int begin, int end, pid_t id);	//build the delta of offset;
		bool equal_lw_sw(std::vector<off_t> delta, std::vector<off_t>::iterator iter, int k);
		std::vector<off_t> init_lw(std::vector<off_t> delta, std::vector<off_t>::iterator iter, int k);
		bool pat_merge(std::vector<PatternElem> &pat_stack, std::vector<off_t> lw, int k);
		vector<PatternElem> build_ps_init(vector<PatternElem> pat_stack, int type, int begin, int end, pid_t id);

		PatternEntry build_entry(std::vector<PatternElem> pat_stack, pid_t id);
		PatternUnit build_unit(PatternElem pat, int begin, int end, pid_t id);

		std::vector<off_t> getCollectOffElem(int type, pid_t id);
		std::vector<size_t> getCollectLenElem(int type, pid_t id);

	//////////for debug;
		void show_collect();
		void show_writebuf();
		void show_readbuf();

	//////////for write; Serialization;
		size_t append_to_buf(string *buf);

	//////////for read; DeSerialization;
	//////////maybe this should be delete;
		void get_ibuf_info(void *ibuf, size_t len);

	//private:
		/* index_collect is collect the index info when the flushIndex() */
		std::map<pid_t, PatternIndexCollect> index_collect;
		/* p_writebuf store the struct that should be serialization and then write to file */
		std::vector<PatternEntry> p_writebuf;
		/* p_readbuf is orignal from the buf that read from file */
		std::vector<PatternEntry> p_readbuf;
};




///////////////////////////////////
//for debug;
///////////////////////////////////
template <typename T>
void show_vector(vector<T> v)
{
	int len = v.size();
	for(int i = 0; i < len; ++i)
	{
		cout << v[i] << "\t" ;
	}
	cout << endl;
}

#endif
